{
  "version": 3,
  "sources": ["../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/config/theme.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/shapes/Circle.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/utils/getRandomColor.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/tree/BinaryTreeNode.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/tree/BinarySearchTreeNode.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/utils/getRGBString.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/helpers/ColorGenerator.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/canvas/Canvas.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/enumns/VisualizationType.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/utils/tree.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/strokes/BezierCurve.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/utils/connectPointsWithBezierCurve.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/canvas/drawPrettyBinaryTree.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/canvas/drawExpandableBinaryTree.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/canvas/drawSimpleBinaryTree.ts", "../../../frontend/main/AlgoAnims main project/node_modules/binary-tree-visualizer/src/canvas/drawBinaryTree.ts"],
  "sourcesContent": ["import {Theme} from './types';\n\nconst theme: Theme = {\n  radius: 20,\n  growthAndShrinkTimes: 1.25,\n  leafNodeSpace: 75,\n  lineHeight: 90,\n  fontSize: 10,\n  textFont: 'Poppins',\n  strokeColor: '#f56042',\n  colorArray: [\n    {bgColor: '#fff2e0', borderColor: '#f56042'},\n  ],\n};\n\n/**\n * Set the user defined theme if required\n *\n * @param {Theme} userDefinedTheme\n */\nexport function setTheme(userDefinedTheme: Partial<Theme>) {\n  const {\n    radius = theme.radius,\n    growthAndShrinkTimes = theme.growthAndShrinkTimes,\n    leafNodeSpace = theme.leafNodeSpace,\n    lineHeight = theme.lineHeight,\n    colorArray = theme.colorArray,\n    textFont = theme.textFont,\n    strokeColor = theme.strokeColor,\n    fontSize = theme.fontSize,\n  } = userDefinedTheme;\n\n  theme.radius = radius;\n  theme.growthAndShrinkTimes = growthAndShrinkTimes;\n  theme.leafNodeSpace = leafNodeSpace;\n  theme.lineHeight = lineHeight;\n  theme.colorArray = colorArray;\n  theme.textFont = textFont;\n  theme.strokeColor = strokeColor;\n  theme.fontSize = fontSize;\n}\n\nexport default theme;\n\n", "import {CanvasComponent} from '..';\nimport theme from '../config/theme';\nimport {CircleColorSettings} from '../config/types';\nimport {RadiusSettings} from './types';\n\n/**\n * Rate at which circle will grow or shrink\n */\nconst growthRate = 0.3;\n\n/**\n * Describes a circle in the canvas\n */\nclass Circle {\n  /**\n   * Radius of the circle\n   */\n  private radiusSettings: RadiusSettings\n\n  /**\n   * The colorId of the circle\n   */\n  private colorId: string = ''\n\n  /**\n   * Color of the circle\n   */\n  private colorSettings: CircleColorSettings\n\n  /**\n   * Value to be displayed inside the circle\n   */\n  private value: string\n\n  /**\n   * X Position of the circle\n   */\n  private x: number = -1\n\n  /**\n   * Y Position of the circle\n   */\n  private y: number = -1\n\n  /**\n   * For constructing a new circle\n   *\n   * @param {string} value\n   * @param {number} radius\n   * @param {CircleColorSettings} colorSettings\n   */\n  constructor(\n      value: string,\n      radius: number,\n      colorSettings: CircleColorSettings,\n  ) {\n    this.value = value;\n    this.colorSettings = colorSettings;\n    this.radiusSettings = {\n      currentRadius: radius,\n      originalRadius: radius,\n      maxRadius: radius * theme.growthAndShrinkTimes,\n      minRadius: radius / theme.growthAndShrinkTimes,\n    };\n  }\n\n  /**\n   * Draw the circle\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} radius\n   * @param {string} color\n   */\n  private drawCircle(\n      ctx: CanvasRenderingContext2D,\n      radius: number,\n      color: string,\n  ) {\n    const {x, y} = this;\n\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n    ctx.fill();\n  }\n\n  /**\n   * Draw the border\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  private drawBorder(ctx: CanvasRenderingContext2D) {\n    const {x, y, colorSettings, radiusSettings: {currentRadius: radius}} = this;\n    const {borderColor} = colorSettings;\n\n    ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n    ctx.strokeStyle = borderColor;\n    ctx.stroke();\n  }\n\n  /**\n   * Write the text\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  private writeText(ctx: CanvasRenderingContext2D) {\n    const {x, y, value, colorSettings} = this;\n    const {borderColor} = colorSettings;\n\n    // Decide font size\n    const fontSize = `${theme.fontSize}pt`;\n    const ySpacing = theme.fontSize/2;\n\n    ctx.fillStyle = borderColor;\n    ctx.font = `${fontSize} ${theme.textFont}`;\n    ctx.textAlign = 'center';\n    ctx.fillText(value, x, y + ySpacing);\n  }\n\n  /**\n   * Get the current radius\n   *\n   * @return {number}\n   */\n  getRadius() {\n    const {\n      radiusSettings: {currentRadius: radius},\n    } = this;\n    return radius;\n  }\n\n  /**\n   * Increase radius of the circle\n   * @param {number} maxRadius\n   * @return {boolean} - Weather size was changed\n   */\n  grow(maxRadius = this.radiusSettings.maxRadius) {\n    const {\n      radiusSettings: {\n        currentRadius,\n      },\n    } = this;\n\n    if (currentRadius < maxRadius) {\n      const originalIncreasedRadius = currentRadius + growthRate;\n      this.radiusSettings.currentRadius = originalIncreasedRadius > maxRadius ?\n      maxRadius : originalIncreasedRadius;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Decrease the radius of the circle\n   * @param {number} minRadius\n   * @return {boolean} - Weather size was changed\n   */\n  shrink(minRadius = this.radiusSettings.minRadius) {\n    const {\n      radiusSettings: {\n        currentRadius,\n      },\n    } = this;\n\n    if (currentRadius > minRadius) {\n      const originalDecreasedRadius = currentRadius - growthRate;\n      this.radiusSettings.currentRadius = originalDecreasedRadius < minRadius ?\n      minRadius : originalDecreasedRadius;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Bring the circle back to its original radius\n   * @return {boolean} - Weather size was changed\n   */\n  restoreCircle() {\n    const {\n      radiusSettings: {\n        currentRadius,\n        originalRadius,\n      },\n    } = this;\n\n    if (currentRadius > originalRadius) {\n      return this.shrink(originalRadius);\n    }\n\n    if (currentRadius < originalRadius) {\n      return this.grow(originalRadius);\n    }\n\n    return false;\n  }\n\n  /**\n   * Set the color id of the circle\n   *\n   * @param {string} colorId\n   */\n  setColorId(colorId: string) {\n    this.colorId = colorId;\n  }\n\n  /**\n   * Set the x and y coordinates of the circle\n   *\n   * @param {number} x\n   * @param {number} y\n   */\n  setCoordinates(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Draw the circle on the screen\n   * Draw the border\n   * Add the text\n   *\n   * @param {CanvasComponent} comp\n   * @return {string} - The color id represented by the unique color\n   */\n  draw(comp: CanvasComponent) {\n    const {\n      radiusSettings: {currentRadius: radius},\n      colorSettings: {bgColor},\n    } = this;\n\n    // Draw circle\n    this.colorId = this.colorId ? this.colorId : comp.getNextColor();\n    this.drawCircle(\n        comp.getContext(),\n        radius,\n        bgColor,\n    );\n    this.drawCircle(\n        comp.getHitContext(),\n        radius,\n        this.colorId,\n    );\n\n    // Draw border\n    this.drawBorder(comp.getContext());\n\n    // Write text\n    this.writeText(comp.getContext());\n\n    // Return the colorId\n    return this.colorId;\n  }\n}\n\nexport default Circle;\n", "import {CircleColorSettings} from '../config/types';\nimport theme from '../config/theme';\n\n/**\n * Get a random color settings\n *\n * @return {CircleColorSettings}\n */\nfunction getRandomColor():CircleColorSettings {\n  const {colorArray} = theme;\n  return colorArray[Math.floor(Math.random() * colorArray.length)];\n}\n\nexport default getRandomColor;\n", "import Circle from '../shapes/Circle';\nimport theme from '../config/theme';\nimport getRandomColor from '../utils/getRandomColor';\n\n/**\n * Describes a node of a binary tree\n */\nclass BinaryTreeNode<T extends string | number> {\n  /**\n   * The value of the node\n   */\n  value: T\n\n  /**\n   * The canvas circle\n   */\n  nodeCircle: Circle\n\n  /**\n   * The left child of the node\n   */\n  left?: BinaryTreeNode<T>\n\n  /**\n   * The right child of the node\n   */\n  right?: BinaryTreeNode<T>\n\n  /**\n   * For constructing a new binary tree node\n   *\n   * @param {T} value\n   */\n  constructor(value: T) {\n    this.value = value;\n    this.nodeCircle = new Circle(\n        `${value}`,\n        theme.radius,\n        getRandomColor(),\n    );\n  }\n\n  /**\n   * Set the left child\n   *\n   * @param {BinaryTreeNode} value\n   */\n  setLeft(value: BinaryTreeNode<T>) {\n    this.left = value;\n  }\n\n  /**\n   * Set the right child\n   *\n   * @param {BinaryTreeNode} value\n   */\n  setRight(value: BinaryTreeNode<T>) {\n    this.right = value;\n  }\n\n  /**\n   * Get the height of the binry tree from the node\n   * Height of root is 1\n   *\n   * @return {number}\n   */\n  getHeight():number {\n    const leftHeight = this.left?.getHeight() || 0;\n    const rightHeight = this.right?.getHeight() || 0;\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n}\n\nexport default BinaryTreeNode;\n", "import BinaryTreeNode from './BinaryTreeNode';\n\n/**\n * A Binary search tree node\n */\nclass BinarySearchTreeNode<T extends string | number>\n  extends BinaryTreeNode<T> {\n    /**\n     * Left child of the node\n     */\n    left?: BinarySearchTreeNode<T>\n\n    /**\n     * Right child of the node\n     */\n    right?: BinarySearchTreeNode<T>\n\n    /**\n     * Set the left child of the node\n     *\n     * @param {BinarySearchTreeNode<T>} value\n     */\n    setLeft(value: BinarySearchTreeNode<T>) {\n      super.setLeft(value);\n    }\n\n    /**\n     * Set the right child of the node\n     *\n     * @param {BinarySearchTreeNode<T>} value\n     */\n    setRight(value: BinarySearchTreeNode<T>) {\n      super.setRight(value);\n    }\n\n    /**\n     * Insert a value into the node\n     * (Using Recursion)\n     *\n     * @param {T} value\n     */\n    insert(value: T) {\n      // Skip equal value\n      if (value === this.value) {\n        return;\n      }\n\n      // When value is lesser\n      if (value < this.value) {\n        if (this.left) {\n          this.left.insert(value);\n          return;\n        }\n        this.setLeft(new BinarySearchTreeNode(value));\n        return;\n      }\n\n      // When value is greater\n      if (this.right) {\n        this.right.insert(value);\n        return;\n      }\n      this.setRight(new BinarySearchTreeNode(value));\n    }\n\n    /**\n     * Find the minimum value from the given node\n     *\n     * @param {BinarySearchTreeNode<T>} node\n     * @return {BinarySearchTreeNode<T>}\n     */\n    findMinimum():BinarySearchTreeNode<T> {\n      if (this.left) {\n        return this.left.findMinimum();\n      }\n      return this;\n    }\n\n    /**\n     * Delete this node\n     *\n     * @param {BinarySearchTreeNode<T>} parent\n     * @return {[\n     *  BinarySearchTreeNode<T>,\n     *  BinarySearchTreeNode<T>\n     * ]} [deletedNode, currentRoot]\n     */\n    deleteThisNode(\n        parent?: BinarySearchTreeNode<T>,\n    ): [BinarySearchTreeNode<T>?, BinarySearchTreeNode<T>?] {\n      // Which direction is this node from the parent\n      const childDirection = parent?.left === this ? 'left' : 'right';\n\n      // Case 1: Delete leaf node\n      if (!this.left && !this.right) {\n        if (parent) {\n          delete parent[childDirection];\n        }\n        return [this];\n      }\n\n      // Case 2: Delete when there is only one child\n      if (this.left && !this.right) {\n        if (parent) {\n          parent[childDirection] = this.left;\n        }\n        return [this, this.left];\n      } else if (this.right && !this.left) {\n        if (parent) {\n          parent[childDirection] = this.right;\n        }\n        return [this, this.right];\n      }\n\n      // Case 3: There are 2 children\n\n      // Step 1: Delete the in order successor\n      const [deletedNode] = this.right!.delete(\n        this.right!.findMinimum().value, this,\n      );\n\n      // Step 2: Set the in order successor as the current node\n      // Deleted node will always be found\n      deletedNode!.left = this.left;\n      deletedNode!.right = this.right;\n      if (parent) {\n        parent[childDirection] = deletedNode;\n      }\n\n      return [this, deletedNode];\n    }\n\n    /**\n     * Delete a node\n     * (Using recursion)\n     *\n     * @param {T} value\n     * @param {BinarySearchTreeNode<T>} parent\n     * @return {[\n     *  BinarySearchTreeNode<T>,\n     *  BinarySearchTreeNode<T>\n     * ]} [deletedNode, currentRoot]\n     */\n    delete(\n        value: T,\n        parent?: BinarySearchTreeNode<T>,\n    ): [BinarySearchTreeNode<T>?, BinarySearchTreeNode<T>?] {\n      // Delete from left node\n      if (value < this.value && this.left) {\n        const [deletedNode] = this.left.delete(value, this);\n        return [deletedNode, this];\n      }\n\n      // Delete from right node\n      if (value > this.value && this.right) {\n        const [deletedNode] = this.right.delete(value, this);\n        return [deletedNode, this];\n      }\n\n      // Delete the current node\n      if (this.value === value) {\n        const res = this.deleteThisNode(parent);\n        delete this.left;\n        delete this.right;\n        return res;\n      }\n\n      return [, this];\n    }\n}\n\nexport default BinarySearchTreeNode;\n", "/**\n * Get RGB string from red green and blue values\n *\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n * @return {string}\n */\nfunction getRGBString(red: number, green: number, blue: number) {\n  return `rgb(${red}, ${green}, ${blue})`;\n}\n\nexport default getRGBString;\n", "import getRGBString from '../utils/getRGBString';\n\n/**\n * The gap between 2 ids\n */\nconst gap = 10;\n\n/**\n * For generating color\n */\nclass ColorGenerator {\n  /**\n   * The red color value\n   */\n  private red = 0\n\n  /**\n   * The green color value\n   */\n  private green = 0\n\n  /**\n   * The blue color value\n   */\n  private blue = 1\n\n  /**\n   * Increment a color\n   *\n   * @param {'red' | 'green' | 'blue'} color\n   */\n  incrementColor(color: 'red' | 'green' | 'blue') {\n    this[color] = (this[color] + gap) % 256;\n  }\n\n  /**\n   * Get the next color\n   * Starts from rgb(0, 0, 0)\n   *\n   * @return {string}\n   */\n  getNextColor() {\n    // Generate the rgb value\n    const color = getRGBString(this.red, this.green, this.blue);\n\n    // Increment the color\n    this.incrementColor('blue');\n    if (this.blue < gap) {\n      this.incrementColor('green');\n      if (this.green < gap) {\n        this.incrementColor('red');\n      }\n    }\n\n    // Return the color\n    return color;\n  }\n}\n\nexport default ColorGenerator;\n", "import ColorGenerator from '../helpers/ColorGenerator';\nimport getRGBString from '../utils/getRGBString';\nimport {GetColorCallBack} from './types';\n\n/**\n * Defines one canvas\n */\nclass CanvasComponent {\n  /**\n   * The canvas element\n   */\n  private $el: HTMLCanvasElement\n\n  /**\n   * This is a hidden canvas element\n   * which is used to redraw all the elements from the canvas\n   * in unique colors.\n   *\n   * This way an element can be easily identified from this hit canvas\n   * just by using the color in O(1)\n   *\n   * Otherwise to identify an element in the canvas it will take O(n)\n   *\n   */\n  private $hitEl: HTMLCanvasElement\n\n  /**\n   * The color generator for generating new color\n   */\n  private colorGenerator: ColorGenerator\n\n  /**\n   * The current hovering color\n   */\n  private currentHoveringColor: string = ''\n\n  /**\n   * For storing the on hover callback\n   */\n  private onHoverCB?: (event: MouseEvent) => void\n\n  /**\n   * For storing the on click callback\n   */\n  private onClickCB?: (event: MouseEvent) => void\n\n  /**\n   * For constructing a new canvas component\n   *\n   * @param {HTMLCanvasElement} $el\n   */\n  constructor($el: HTMLCanvasElement) {\n    const $hitEl = document.createElement('canvas');\n\n    this.$el = $el;\n    this.$hitEl = $hitEl;\n    this.colorGenerator = new ColorGenerator();\n  }\n\n  /**\n   * Clears the canvas\n   */\n  clearCanvas() {\n    const {height, width} = this.$el;\n    this.getContext().clearRect(0, 0, width, height);\n  }\n\n  /**\n   * Set the maximum width and height\n   *\n   * @param {number} height\n   * @param {number} width\n   */\n  setMaxWidthAndHeight(height: number, width: number) {\n    this.$hitEl.height = this.$el.height = height;\n    this.$hitEl.width = this.$el.width = width;\n  }\n\n  /**\n   * Get the hit 2d context\n   *\n   * @return {CanvasComponent}\n   */\n  getHitContext(): CanvasRenderingContext2D {\n    const ctx = this.$hitEl.getContext('2d');\n    if (!ctx) {\n      throw new Error('Cannot get 2d context');\n    }\n\n    return ctx;\n  }\n\n  /**\n   * Get the 2d context\n   *\n   * @return {CanvasRenderingContext2D}\n   */\n  getContext(): CanvasRenderingContext2D {\n    const ctx = this.$el.getContext('2d');\n    if (!ctx) {\n      throw new Error('Cannot get 2d context');\n    }\n\n    return ctx;\n  }\n\n  /**\n   * Get the next color from the color generator\n   *\n   * @return {string}\n   */\n  getNextColor() {\n    return this.colorGenerator.getNextColor();\n  }\n\n  /**\n   * On hover get the canvas hit color\n   *\n   * @param {GetColorCallBack} cb\n   */\n  onHover(cb: GetColorCallBack) {\n    // Clear previous listeners\n    if (this.onHoverCB) {\n      this.$el.removeEventListener('mousemove', this.onHoverCB);\n    }\n\n    // Set the callback\n    this.onHoverCB = (event: MouseEvent) => {\n      const {pageX, pageY} = event;\n      const {data: pixel} = this.getHitContext().getImageData(\n          pageX - this.$el.offsetLeft,\n          pageY - this.$el.offsetTop,\n          1, 1,\n      );\n\n      // Callback should only be called on color change\n      const color = getRGBString(pixel[0], pixel[1], pixel[2]);\n      if (this.currentHoveringColor !== color) {\n        this.currentHoveringColor = color;\n        cb(color);\n      }\n    };\n\n    // Add the event listener\n    this.$el.addEventListener('mousemove', this.onHoverCB);\n  }\n\n  /**\n   * On click of canvas get the hit color\n   *\n   * @param {GetColorCallBack} cb\n   */\n  onClick(cb: GetColorCallBack) {\n    // Clear previous listeners\n    if (this.onClickCB) {\n      this.$el.removeEventListener('click', this.onClickCB);\n    }\n\n    // Set the callback\n    this.onClickCB = (event: MouseEvent) => {\n      const {pageX, pageY} = event;\n      console.log(pageX, pageY);\n      const {data: pixel} = this.getHitContext().getImageData(\n          pageX - this.$el.offsetLeft,\n          pageY - this.$el.offsetTop,\n          1, 1,\n      );\n      cb(getRGBString(pixel[0], pixel[1], pixel[2]));\n    };\n\n    // Add the event listener\n    this.$el.addEventListener('click', this.onClickCB);\n  }\n}\n\nexport default CanvasComponent;\n\n\n", "export enum VisualizationType {\n  SIMPLE,\n  PRETTY,\n  EXPANDABLE,\n  HIGHLIGHT\n}\n", "import theme from '../config/theme';\n\n/**\n * Get the max number of leaf nodes from height of the binary tree\n *\n * @param {number} treeHeight - Height of the tree (number of nodes from)\n * @return {number} - Maximum number of leaf nodes\n */\nexport function getMaxLeafNodesFromHeight(treeHeight: number) {\n  return 2 ** (treeHeight-1);\n}\n\n/**\n * Maximum canvas width required from number of tree nodes\n *\n * @param {number} maxNodes - Maximum number of nodes\n * @return {number} - The max width required\n */\nexport function getCanvasWidthFromMaxNodeSpacing(maxNodes: number) {\n  return (maxNodes + 2) * theme.leafNodeSpace;\n}\n\n/**\n * Get the x position from given horizontal node position\n *\n * @param {number} nodes - The number of nodes from the left\n * @return {number} - The x position\n */\nexport function getXPositionFromGivenHorizontalNodePosition(nodes: number) {\n  return (nodes) * theme.leafNodeSpace;\n}\n\n/**\n * Get canvas height from the tree height\n *\n * @param {number} treeHeight - Height of the tree (number of nodes from)\n * @return {number} - The canvas height in px\n */\nexport function getCanvasHeightFromTreeHeight(treeHeight: number) {\n  return (treeHeight) * theme.lineHeight;\n}\n\n/**\n * Get required and actual height and width\n *\n * @param {number} maxNodeSpacing\n * @param {number} heightOfTree\n * @param {number} maxWidth\n * @param {number} maxHeight\n * @return {{\n *  maxCanvasHeightRequired: number,\n *  maxCanvasWidthRequired:number,\n *  actualMaxHeight: number,\n *  actualMaxWidth: number\n * }}\n */\nexport function getRequiredAndActualHeightAndWidth(\n    maxNodeSpacing: number,\n    heightOfTree: number,\n    maxWidth: number,\n    maxHeight: number,\n) {\n  const maxCanvasWidthRequired = getCanvasWidthFromMaxNodeSpacing(\n      maxNodeSpacing,\n  );\n  const maxCanvasHeightRequired = getCanvasHeightFromTreeHeight(heightOfTree+1);\n  const actualMaxWidth = maxCanvasWidthRequired > maxWidth ?\n    maxCanvasWidthRequired : maxWidth;\n  const actualMaxHeight = maxCanvasHeightRequired > maxHeight ?\n    maxCanvasHeightRequired : maxHeight;\n\n  return {\n    maxCanvasHeightRequired,\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth,\n  };\n}\n", "import {Point} from '../types/Point';\n\n/**\n * Describes a bezier curve\n */\nclass BezierCurve {\n  /**\n   * X Configurations\n   */\n  xStart: number\n  cp1x: number\n  cp2x: number\n  xEnd: number\n\n  /**\n   * Y Configurations\n   */\n  yStart: number\n  cp1y: number\n  cp2y: number\n  yEnd: number\n\n  /**\n   * Color of the curve\n   */\n  color: string\n\n  /**\n   * Construct a new bezier curve\n   *\n   * @param {string} color\n   * @param {Point} start\n   * @param {Point} cp1\n   * @param {Point} cp2\n   * @param {Point} end\n   */\n  constructor(\n      color: string,\n      start: Point,\n      cp1: Point,\n      cp2: Point,\n      end: Point,\n  ) {\n    const {x: xStart, y: yStart} = start;\n    const {x: cp1x, y: cp1y} = cp1;\n    const {x: cp2x, y: cp2y} = cp2;\n    const {x: xEnd, y: yEnd} = end;\n\n    this.color = color;\n    this.xStart = xStart;\n    this.yStart = yStart;\n    this.cp1x = cp1x;\n    this.cp1y = cp1y;\n    this.cp2x = cp2x;\n    this.cp2y = cp2y;\n    this.xEnd = xEnd;\n    this.yEnd = yEnd;\n  }\n\n  /**\n   * Draw the bezier curve\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.beginPath();\n    ctx.moveTo(this.xStart, this.yStart);\n    ctx.strokeStyle = this.color;\n    ctx.bezierCurveTo(\n        this.cp1x,\n        this.cp1y,\n        this.cp2x,\n        this.cp2y,\n        this.xEnd,\n        this.yEnd,\n    );\n    ctx.stroke();\n  }\n}\n\n\nexport default BezierCurve;\n", "import CanvasComponent from '../canvas/Canvas';\nimport theme from '../config/theme';\nimport BezierCurve from '../strokes/BezierCurve';\nimport {\n  HorizontalStartAndEndInput,\n  VerticalStartAndEndInput,\n} from '../canvas/types';\n\n/**\n * Connect two points with a bezier curve\n *\n * @param {CanvasComponent} canvasComponent\n * @param {HorizontalStartAndEndInput} horizontalConfig\n * @param {VerticalStartAndEndInput} verticalConfig\n */\nfunction connectPointsWithBezierCurve(\n    canvasComponent: CanvasComponent,\n    horizontalConfig: HorizontalStartAndEndInput,\n    verticalConfig: VerticalStartAndEndInput,\n) {\n// X, Y Calculation\n  const {xStart, xEnd} = horizontalConfig;\n  const {yStart, yEnd} = verticalConfig;\n  const halfY = (yStart + yEnd) / 2;\n  const halfX = (xStart + xEnd) / 2;\n\n  // Draw the bezier curve\n  const berzierCurve = new BezierCurve(\n      theme.strokeColor,\n      {x: xStart, y: yStart},\n      {x: halfX, y: halfY},\n      {x: xEnd, y: halfY},\n      {x: xEnd, y: yEnd},\n  );\n  berzierCurve.draw(canvasComponent.getContext());\n}\n\nexport default connectPointsWithBezierCurve;\n", "import CanvasComponent from './Canvas';\nimport theme from '../config/theme';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {Point} from '../types/Point';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getRequiredAndActualHeightAndWidth,\n  getXPositionFromGivenHorizontalNodePosition,\n} from '../utils/tree';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\nimport {\n  IndividualInputOptions,\n  LeftAndRightSpacing,\n} from './types';\n\n/**\n * The current animation frame that is going on\n */\nlet animationFrameId: number;\n\n/**\n * Current color that is being hovered on\n */\nlet hoveredColorId: string;\n\n/**\n * Spacing map for storing space requirements\n */\nlet spacingMap: Map<BinaryTreeNode<string | number>, LeftAndRightSpacing>;\n\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n */\nfunction requestAnimationFrame(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n) {\n  // Clear existing animation frame\n  if (animationFrameId) {\n    cancelAnimationFrame(animationFrameId);\n  }\n\n  // Request a new one\n  animationFrameId = window.requestAnimationFrame(() => {\n    canvasComponent.clearCanvas();\n    const requiredRedraw = recursivelyDrawNodes(\n        root, canvasComponent, position, highlightMode);\n    if (requiredRedraw) {\n      requestAnimationFrame(root, canvasComponent, position, highlightMode);\n    }\n  });\n}\n\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean} Weather redraw is required\n */\nfunction drawSingleNode(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n) {\n  const {x, y} = position;\n  node.nodeCircle.setCoordinates(x, y);\n\n  // Grow or shrink while hover\n  const colorId = node.nodeCircle.draw(comp);\n  if (colorId === hoveredColorId && highlightMode) {\n    return node.nodeCircle.grow();\n  } else {\n    return node.nodeCircle.restoreCircle();\n  }\n}\n\n/**\n * Recursively draw all the nodes for a pretty tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean}\n */\nfunction recursivelyDrawNodes(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n): boolean {\n  const {x: xPosition, y: yPosition} = position;\n\n  // Draw the node\n  let requiredRedraw = drawSingleNode(\n      root,\n      canvasComponent,\n      {x: xPosition, y: yPosition},\n      highlightMode,\n  );\n  root.nodeCircle.setCoordinates(xPosition, yPosition);\n  root.nodeCircle.draw(canvasComponent);\n\n  // Root spacings\n  const {left, right} = spacingMap.get(root)!;\n\n  // Draw the left child\n  if (root.left) {\n    const leftOfLeft = spacingMap.get(root.left)!.left;\n    const childYPosition = yPosition + theme.lineHeight;\n    const leftPosition = {\n      x: xPosition - getXPositionFromGivenHorizontalNodePosition(\n          left - leftOfLeft,\n      ),\n      y: childYPosition,\n    };\n\n    requiredRedraw = recursivelyDrawNodes(\n        root.left,\n        canvasComponent,\n        leftPosition,\n        highlightMode,\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: leftPosition.x,\n    }, {\n      yStart: yPosition + root.nodeCircle.getRadius(),\n      yEnd: childYPosition - root.left.nodeCircle.getRadius(),\n    });\n  }\n\n  // Draw the right child\n  if (root.right) {\n    const rightOfRight = spacingMap.get(root.right)!.right;\n    const childYPosition = yPosition + theme.lineHeight;\n    const rightPosition = {\n      x: xPosition + getXPositionFromGivenHorizontalNodePosition(\n          right - rightOfRight,\n      ),\n      y: childYPosition,\n    };\n\n    requiredRedraw = recursivelyDrawNodes(\n        root.right,\n        canvasComponent,\n        rightPosition,\n        highlightMode,\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: rightPosition.x,\n    }, {\n      yStart: yPosition + root.nodeCircle.getRadius(),\n      yEnd: childYPosition - root.right.nodeCircle.getRadius(),\n    });\n  }\n\n  return requiredRedraw;\n}\n\n/**\n * Calculates the spacing required recursively\n *\n * @param {BinaryTreeNode<string | number>} root\n * @return {number} - The spacing requirement of that node\n */\nfunction calculateSpacingMapRecursively(\n    root: BinaryTreeNode<string | number>,\n): number {\n  const left = root.left ? calculateSpacingMapRecursively(\n      root.left,\n  ) + 0.5: 0;\n  const right = root.right ? calculateSpacingMapRecursively(\n      root.right,\n  ) + 0.5: 0;\n  spacingMap.set(root, {\n    left,\n    right,\n  });\n\n  return left + right;\n}\n\n/**\n * Draw a pretty binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawPrettyBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  spacingMap = new Map();\n  const maxNodeSpacing = calculateSpacingMapRecursively(root);\n  const heightOfTree = root.getHeight();\n  const {maxHeight, maxWidth, highlightMode} = options;\n\n  // Calculate canvas spacing requirements\n  const {\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth,\n  } = getRequiredAndActualHeightAndWidth(\n      maxNodeSpacing,\n      heightOfTree,\n      maxWidth,\n      maxHeight,\n  );\n\n  // Init calculation\n  const left = spacingMap.get(root)!.left;\n  const midPointInCanvas = actualMaxWidth / 2;\n  const xStart = (midPointInCanvas - maxCanvasWidthRequired / 2);\n\n  // Initialize the canvas\n  canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);\n\n  /**\n   * Hover event handler\n   */\n  canvasComponent.onHover((color) => {\n    hoveredColorId = color;\n    requestAnimationFrame(root, canvasComponent, {\n      x: xStart + getXPositionFromGivenHorizontalNodePosition(left+1),\n      y: getCanvasHeightFromTreeHeight(0.5),\n    }, Boolean(highlightMode));\n  });\n\n  // Recursively draw all nodes\n  requestAnimationFrame(root, canvasComponent, {\n    x: xStart + getXPositionFromGivenHorizontalNodePosition(left+1),\n    y: getCanvasHeightFromTreeHeight(0.5),\n  }, Boolean(highlightMode));\n}\n\nexport default drawPrettyBinaryTree;\n", "import CanvasComponent from './Canvas';\nimport theme from '../config/theme';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {Point} from '../types/Point';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getCanvasWidthFromMaxNodeSpacing,\n  getXPositionFromGivenHorizontalNodePosition,\n} from '../utils/tree';\nimport {IndividualInputOptions, PathArray} from './types';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\n\n/**\n * The current animation frame that is going on\n */\nlet animationFrameId: number;\n\n/**\n * Array of all children that needs printing\n */\nlet globalPathArray: PathArray;\n\n/**\n * Current color that is being hovered on\n */\nlet hoveredColorId: string;\n\n/**\n * Map storing the colorId to the path array\n */\nlet colorIdToPathMap: Map<string, PathArray> = new Map();\n\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\nfunction requestAnimationFrame(\n    root: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Clear existing animation frame\n  if (animationFrameId) {\n    cancelAnimationFrame(animationFrameId);\n  }\n\n  // Request a new one\n  animationFrameId = window.requestAnimationFrame(\n      () => animationFrameCB(root, comp, options),\n  );\n}\n\n\n/**\n * Get the node height from print array\n *\n * @return {number}\n */\nfunction getNodeHeightFromGlobalPathArray() {\n  return globalPathArray.length + 1;\n}\n\n\n/**\n * Get the node width from the print array\n *\n * @return {{\n *  left: number,\n *  right: number\n * }}\n */\nfunction getNodeWidthFromGlobalPathArray() {\n  let left = 0;\n  let right = 0;\n  let current = 0;\n\n  for (const childDirection of globalPathArray) {\n    if (childDirection === 'left') {\n      current -= 1;\n    } else {\n      current += 1;\n    }\n    if (current < 0) {\n      left = Math.max(Math.abs(current), left);\n    } else {\n      right = Math.max(current, right);\n    }\n  }\n\n  return {\n    left, right,\n  };\n}\n\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {PathArray} pathArray\n * @param {Point} position\n * @return {boolean} Weather redraw is required\n */\nfunction drawSingleNode(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    pathArray: PathArray,\n    position: Point,\n) {\n  const {x, y} = position;\n  const doesNodeHaveChildren = Boolean(node.left || node.right);\n  node.nodeCircle.setCoordinates(x, y);\n\n  // Grow or shrink while hover\n  const colorId = node.nodeCircle.draw(comp);\n  colorIdToPathMap.set(colorId, pathArray);\n  if (colorId === hoveredColorId && doesNodeHaveChildren) {\n    return node.nodeCircle.grow();\n  } else {\n    return node.nodeCircle.restoreCircle();\n  }\n}\n\n/**\n * Draw both the children if required\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {number} xPosition\n * @param {number} nodeHeight\n * @param {PathArray} pathArray\n * @return {boolean}\n */\nfunction drawChildren(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    xPosition: number,\n    nodeHeight: number,\n    pathArray: PathArray,\n) {\n  const currentHeight = getCanvasHeightFromTreeHeight(nodeHeight);\n  const childHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);\n  let requiredRedraw = false;\n\n  // Draw the left child\n  if (node.left) {\n    const currentPathArray : PathArray = node.left.left || node.left.right ?\n      [...pathArray, 'left'] : [...pathArray];\n    const xLeft = xPosition - (0.5 * theme.leafNodeSpace);\n\n    requiredRedraw = drawSingleNode(\n        node.left,\n        comp,\n        currentPathArray, {\n          x: xLeft,\n          y: childHeight,\n        },\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(comp, {\n      xStart: xPosition,\n      xEnd: xLeft,\n    }, {\n      yStart: currentHeight + node.nodeCircle.getRadius(),\n      yEnd: childHeight - node.left.nodeCircle.getRadius(),\n    });\n  }\n\n  // Draw the right child\n  if (node.right) {\n    const currentPathArray : PathArray = node.right.left || node.right.right ?\n      [...pathArray, 'right'] : [...pathArray];\n    const xRight = xPosition + (0.5 * theme.leafNodeSpace);\n\n    requiredRedraw = drawSingleNode(\n        node.right,\n        comp,\n        currentPathArray, {\n          x: xRight,\n          y: childHeight,\n        },\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(comp, {\n      xStart: xPosition,\n      xEnd: xRight,\n    }, {\n      yStart: currentHeight + node.nodeCircle.getRadius(),\n      yEnd: childHeight - node.right.nodeCircle.getRadius(),\n    });\n  }\n\n  return requiredRedraw;\n}\n\n\n/**\n * Draw all the nodes by following print array\n *\n * @param {BinaryTreeNode} root\n * @param {CanvasComponent} comp\n * @param {number} xRootPosition\n * @return {boolean} - Weather animated redraw is required\n */\nfunction drawAllNodes(\n    root:BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    xRootPosition: number): boolean {\n  // Draw root\n  let currentNode = root;\n  let xPosition = xRootPosition;\n  let currentNodeHeight = 0.5;\n  const currentPathArray: Array<'left' | 'right'> = [];\n  let requiredRedraw = drawSingleNode(root, comp, [...currentPathArray], {\n    x: xPosition,\n    y: getCanvasHeightFromTreeHeight(currentNodeHeight),\n  });\n\n  // Draw all the children according to the path\n  for (const currentPath of globalPathArray) {\n    requiredRedraw = drawChildren(\n        currentNode,\n        comp,\n        xPosition,\n        currentNodeHeight,\n        currentPathArray,\n    ) || requiredRedraw;\n\n    if (currentPath === 'left') {\n      currentNode = currentNode.left!;\n      xPosition = xPosition - (0.5 * theme.leafNodeSpace);\n      currentPathArray.push('left');\n    } else {\n      currentNode = currentNode.right!;\n      xPosition = xPosition + (0.5 * theme.leafNodeSpace);\n      currentPathArray.push('right');\n    }\n    currentNodeHeight += 1;\n  }\n\n  // Draw the children of the last element in the path\n  requiredRedraw = drawChildren(\n      currentNode,\n      comp,\n      xPosition,\n      currentNodeHeight,\n      currentPathArray,\n  ) || requiredRedraw;\n\n  // Return if redraw is required\n  return requiredRedraw;\n}\n\n/**\n * Animation frame call back function that will recursively be called.\n * In case animation is required\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\nfunction animationFrameCB(\n    root: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Height and width calculations\n  const nodeHeight = getNodeHeightFromGlobalPathArray();\n  const {\n    left: leftNodeWidth,\n    right: rightNodeWidth,\n  } = getNodeWidthFromGlobalPathArray();\n  const requiredHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);\n  const requiredWidth = getCanvasWidthFromMaxNodeSpacing(\n      leftNodeWidth+rightNodeWidth,\n  );\n  const actualHeight = Math.max(requiredHeight, options.maxHeight);\n  const actualWidth = Math.max(requiredWidth, options.maxWidth);\n  const xStart = (actualWidth/2) - (requiredWidth/2);\n\n  // Set the height and width\n  // This also clears the canvas. So no need to clear it manually.\n  comp.setMaxWidthAndHeight(actualHeight, actualWidth);\n\n  // Initialize color id to path map\n  colorIdToPathMap = new Map();\n\n  // Draw and check if redraw is required\n  const requiredRedraw = drawAllNodes(\n      root,\n      comp,\n      xStart + getXPositionFromGivenHorizontalNodePosition(leftNodeWidth + 1),\n  );\n  if (requiredRedraw) {\n    requestAnimationFrame(root, comp, options);\n  }\n}\n\n/**\n * Draw an expandable binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawExpandableBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Initialization\n  globalPathArray = [];\n\n  /**\n   * Click event handler\n   */\n  canvasComponent.onClick((color) => {\n    globalPathArray = colorIdToPathMap.get(color) || globalPathArray;\n    requestAnimationFrame(root, canvasComponent, options);\n  });\n\n  /**\n   * Hover event handler\n   */\n  canvasComponent.onHover((color) => {\n    hoveredColorId = color;\n    requestAnimationFrame(root, canvasComponent, options);\n  });\n\n  // Draw frame\n  requestAnimationFrame(root, canvasComponent, options);\n}\n\nexport default drawExpandableBinaryTree;\n", "import CanvasComponent from './Canvas';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport theme from '../config/theme';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getMaxLeafNodesFromHeight,\n  getRequiredAndActualHeightAndWidth,\n} from '../utils/tree';\nimport {\n  HorizontalStartAndEndInput,\n  IndividualInputOptions,\n} from './types';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\n\n/**\n * Recursively draw all the nodes\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {number} currentLine\n * @param {HorizontalStartAndEndInput} horizontalConfig\n */\nfunction recursivelyDrawNodes(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    currentLine: number,\n    horizontalConfig: HorizontalStartAndEndInput,\n) {\n  // X Calculation\n  const {xStart, xEnd} = horizontalConfig;\n  const xPosition = (xStart + xEnd) / 2;\n\n  // Y Calculation\n  const yPosition = currentLine * theme.lineHeight;\n\n  // Draw the node\n  root.nodeCircle.setCoordinates(xPosition, yPosition);\n  root.nodeCircle.draw(canvasComponent);\n\n\n  // Draw the left child nodes\n  // Radius is added and subtracted from y to move the line outside the circle\n  if (root.left) {\n    recursivelyDrawNodes(root.left, canvasComponent, currentLine+1, {\n      xStart,\n      xEnd: xPosition,\n    });\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: (xStart + xPosition) / 2,\n    }, {\n      yStart: yPosition + theme.radius,\n      yEnd: getCanvasHeightFromTreeHeight(currentLine + 1) - theme.radius,\n    });\n  }\n\n  if (root.right) {\n    recursivelyDrawNodes(root.right, canvasComponent, currentLine+1, {\n      xStart: xPosition,\n      xEnd,\n    });\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: (xPosition + xEnd) / 2,\n    }, {\n      yStart: yPosition + theme.radius,\n      yEnd: getCanvasHeightFromTreeHeight(currentLine + 1) - theme.radius,\n    });\n  }\n}\n\n/**\n * Draw an expandable binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawSimpleBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  const heightOfTree = root.getHeight();\n  const maxNumberOfLeafNodes = getMaxLeafNodesFromHeight(heightOfTree);\n  const {maxHeight, maxWidth} = options;\n\n  // Max height and width requirements\n  const {\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth,\n  } = getRequiredAndActualHeightAndWidth(\n      maxNumberOfLeafNodes,\n      heightOfTree,\n      maxWidth,\n      maxHeight,\n  );\n\n  // Init calculation\n  const midPointInCanvas = actualMaxWidth / 2;\n  const xStart = (midPointInCanvas - maxCanvasWidthRequired / 2) +\n  theme.leafNodeSpace;\n  const xEnd = (midPointInCanvas + maxCanvasWidthRequired / 2) -\n  theme.leafNodeSpace;\n\n  // Initialize the canvas\n  canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);\n\n  // Recursively draw the tree\n  recursivelyDrawNodes(root, canvasComponent, 0.5, {xStart, xEnd});\n}\n\nexport default drawSimpleBinaryTree;\n", "import BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {VisualizationType} from '../enumns/VisualizationType';\nimport drawPrettyBinaryTree from './drawPrettyBinaryTree';\nimport drawExpandableBinaryTree from './drawExpandableBinaryTree';\nimport drawSimpleBinaryTree from './drawSimpleBinaryTree';\nimport {MainInputOptions} from './types';\nimport CanvasComponent from './Canvas';\n\n// For keeping track of canvas components for canvas elements\nconst canvasMap: Map<HTMLCanvasElement, CanvasComponent> = new Map();\n\n/**\n * Draw a binary tree in one of the given types\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {HTMLCanvasElement} canvasElement\n * @param {Partial<MainInputOptions>} options\n */\nfunction drawBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasElement: HTMLCanvasElement,\n    options: Partial<MainInputOptions> = {},\n) {\n  const {\n    type = VisualizationType.SIMPLE,\n    maxHeight = window.innerHeight,\n    maxWidth = window.innerWidth,\n  } = options;\n\n  const canvasComponent = canvasMap.get(canvasElement) ||\n  new CanvasComponent(canvasElement);\n  canvasMap.set(canvasElement, canvasComponent);\n\n  switch (type) {\n    case VisualizationType.PRETTY:\n      drawPrettyBinaryTree(root, canvasComponent, {\n        maxHeight,\n        maxWidth,\n      });\n      break;\n\n    case VisualizationType.EXPANDABLE:\n      drawExpandableBinaryTree(root, canvasComponent, {\n        maxHeight,\n        maxWidth,\n      });\n      break;\n\n    case VisualizationType.HIGHLIGHT:\n      drawPrettyBinaryTree(root, canvasComponent, {\n        maxHeight,\n        maxWidth,\n        highlightMode: true,\n      });\n      break;\n\n    default:\n      drawSimpleBinaryTree(root, canvasComponent, {\n        maxHeight,\n        maxWidth,\n      });\n      break;\n  }\n}\n\nexport default drawBinaryTree;\n"],
  "mappings": "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",
  "names": ["VisualizationType", "animationFrameId", "hoveredColorId", "requestAnimationFrame", "drawSingleNode", "recursivelyDrawNodes"]
}
